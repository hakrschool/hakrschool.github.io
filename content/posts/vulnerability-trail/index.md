---
title: "Vulnerability Trail"
date: February 25 2024
draft: false
description: "A post showing the vulnerability trail to help determine where to fix the issue."
summary: "A post showing the vulnerability trail to help determine where to fix the issue."
slug: "vulnerability-trail"
layout: "simple"
---
> ### KEY TAKEAWAYS:
> - If you could watch the trail of a vulnerability, it is then obvious for you to know where to fix the problem.
***
Let’s start with a tale, Bunny Trail.
# :rabbit2:. . . . 

Imagine you have a beautiful garden :house_with_garden: in your yard. <br>
But there is a problem. All your favorite veggies :carrot: (and some edible plants :seedling:) are getting eaten up by bunnies :rabbit: at night.<br>
What do you do to solve this? <br>

 - I would put a wired mesh around each plant bed. Would this solve the problem?
 - I would place multiple traps in the yard to catch the bunnies. Would this solve the problem, instead?
 - I would install a camera, watch the trail to find how the bunnies are entering the yard. Then close that opening or hole to stop the bunnies from even entering the yard in future.<br> 
Isn't this better?

The software `VULNERABILITY TRAIL` is no different. <br> 
If you could watch the trail of a vulnerability, it is then obvious for you to know where to fix the problem.

Look at the typical vulnerability trail in a Web Application code:

{{< figure src="VulnTrail.png" caption="Simplified version of the Vulnerability Trail in a typical Web Application code" >}}

As you can see, the vulnerability is entering from `TRAIL 1`.<br>
This is the user INPUT in the browser on client side.

So you ask, is this where we need to fix the problem to stop the vulnerability from entering our system?<br>
To answer that, let’s see what we can do to fix the problem in TRAIL 1. 

In our client-side UI code, we could add **input validations** so that unexpected inputs :lady_beetle: are not allowed in the UI input fields.<br>

So, we are all good then, right? The user cannot type in and enter malicious payloads :lady_beetle:, which means the vulnerability cannot enter the system. <br>
Well, unfortunately NO.<br> 
The UI validation code can be easily bypassed. The browser is merely a HTTP client that is sending HTTP requests to the back-end server. <br>
One could use intercepting tools to modify the request parameters after input validations are done OR trick a user (victim) to click on malicious links that send HTTP requests (through victim’s browser).

{{< alert lightbulb>}}
`TRAIL 1 SUMMARY`: We **must add input validations** in UI as a good coding practice, but be clearly aware that this validation could be **easily bypassed** and **not sufficient**.
{{< /alert >}}<br>

Which then takes us to `TRAIL 2`.<br>
This is the *entry point* for the vulnerability into our **back-end system**, which means, this is the :exclamation:**most important trail step** out of all of them.

Once the HTTP request inputs are read for the first time, if we can perform a **thorough input validations** here, then this alone can **ELIMINATE A CLASS OF VULNERABILITIES** in our software’s. 

In my 2 decades of security experience, most (if not all) of the vulnerabilities that I have come across, are due to simply failing to have a proper input validation in this trail 2 step, period. 

Let’s examine the Vulnerability Trail image above and the user input fields `Name` and `Age`.<br>
To perform a thorough input validation, one needs to understand the exact requirements on the input fields.<br> 
Here are some example requirements for these input fields,

The `Name` field:
```
> Accepts only strings (no special characters).
> Could be lower or UPPER case. 
```
The `Age` field:
```
> Accepts only numbers (no special characters).
> Min age is 18 and max age is 100.
```

Isn’t this simple to validate?<br> 
The input fields could be anything (Ex: *email address, phone number, xml data, IP address, json,* etc.)<br>
If you do the input validations correctly in trail 2, rest assured you **eliminated a mass class of vulnerabilities**.<br>
 
To put this in perspective, let’s look at the **MITRE 2023 CWE (Common Weakness Enumeration) Top 25** Most dangerous software weaknesses. 

{{< figure src="cwe25.png" caption="[Official Source](https://cwe.mitre.org/top25/archive/2023/2023_top25_list.html)" >}}

`XSS` and `SQLi` are in the top 3 (for many years!!!) most dangerous and common vulnerabilities out there. <br>

This is unbelievable but unfortunately is true. The reason I say unbelievable is because if you see the vulnerability trail image, these issues crossed all the trail steps without being detected by the code authors (primary and secondary). Then comes the security team who also failed to detect these vulnerabilities (either through code review or performing pen testing). Then the software is released to the world/customer and some external security researcher uncovers this (or internally found) and a CVE is assigned. The top CWE 25 is determined based on the CVE submissions in previous years.

What does this tell you? <br>
It’s simple. Lack of awareness on **secure coding best practices** and **not knowing how important proper input validations** are in Trail 2. <br>

{{< alert lightbulb>}}
`TRAIL 2 SUMMARY`: A **thorough input validation** done correctly in trail 2 will vastly **eliminate** these top 2 issues (and possibly other types) right there.<br>
{{< /alert >}}<br>

Before I conclude, I want to mention at a high level that beyond Trail 2, we must have **secure coding best practices** in Trail 3 (*Ex: Using prepared statements while building SQL query*) and Trail 4 (*Ex: escaping the user inputs*) as well to achieve **defense in depth** for these type of issues.
***